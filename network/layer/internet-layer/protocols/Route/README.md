# 路由

路由分为 **静态路由** 和 **动态路由**。静态路由可以配置复杂的策略路由，控制转发策略。动态路由有两种主流算法：`距离矢量算法` 和 `链路状态算法`，基于这两种算法产生了两种协议：`BGP 协议` 和 `OSPF 协议`。

## 静态路由

路由器实则是一台含有多张网卡的网络设备，当一个入口的网络包到达路由器时，它会根据一张本地的 **路由表** 来决定如何正确地转发流量。一张路由表包含若干条路由规则，每条规则至少包含以下三项信息：

| 规则项目   | 描述                   | 示例           |
| ---------- | ---------------------- | -------------- |
| 目的网络   | 网络包发往何处？       | 10.176.48.0/20 |
| 出口设备   | 网络包从哪个网口发出？ | eth1           |
| 下一跳网关 | 下一个路由器的地址     | 10.176.32.1    |

> **下一跳网关** 必须和 **出口设备的地址** 在同一局域网。因为要将网络包从出口设备转发到下一跳网关，需要知道下一跳网关的 MAC 地址，而 MAC 地址是一个局域网内才有效的地址；否则会出错：**RTNETLINK answers: Network is unreachable**

### 根据目的 IP 地址配置路由

```sh
# 缺省表名时添加规则到 main 路由表（via 指定的是下一跳）
$ ip route add 10.176.48.0/20 via 10.176.32.1 dev eth1

# 添加规则到 10 路由表（只能用数字命名表名）
$ ip route add 10.176.48.0/20 via 10.176.32.1 dev eth1 table 10

# 查询
$ ip route show # 缺省时查询 main 路由表
$ ip route show table main # 查询 main 路由表
$ ip route show table 10   # 查询 10 路由表
```

### 配置策略路由

除了可以根据数据包的 `目的 IP 地址` 配置路由外，还可以根据 `源 IP 地址` 来选择路由表，即不同来源的数据包查看不同的路由表，这种方式称为 **策略路由**。配置流程：

1. 配置多张路由表（见上节）
2. 根据 `源 IP 地址`、`入口设备`、`TOS` 等信息选择相应的路由表
3. 数据包在路由表中查找路由，不同来源的数据包走不同的路由

```sh
# 来自 192.168.1.0/24 网段的数据包使用 table 10 的路由表
$ ip rule add from 192.168.1.0/24 table 10

# 来自 192.168.2.0/24 网段的数据包使用 table 20 的路由表
$ ip rule add from 192.168.2.0/24 table 20

# 查询
$ ip rule show
0:      from all lookup local
32764:  from 192.168.2.0/24 lookup 20
32765:  from 192.168.1.0/24 lookup 10
32766:  from all lookup main
32767:  from all lookup default
```

### 设置路由优先级

```sh
# 一条路由规则走多条路径，下一跳分别是 100.100.100.1 和 200.200.200.1，权重分别是 1 和 2
$ ip route add default scope global nexthop via 100.100.100.1 weight 1 nexthop via 200.200.200.1 weight 2
```

![示例图](../.images/rule-with-multipath.png)

示例说明：

* 房东从运营商那里拉了两根网线，分别属于两个运营商，一个带宽大一些，一个带宽小一些
* 家中有两个租客都把线连接到了路由器（带两个 WAN）上，IP 地址为 `192.168.1.101/24` 和 `192.168.1.102/24`，网关都是 `192.168.1.1/24`
* 家中的网段是私有网段，出去的包需要 NAT 成公网 IP 地址，所以路由器是一个 NAT 路由器
* 运营商里面也有一个 IP 地址，是在运营商网络里面的网关；不同的运营商方法不一样:
  * 有的是 `/32`，即一个一对一连接；运营商 1 给路由器分配的地址是 `183.134.189.34/32`，而运营商网络中的网关是 `183.134.188.1/32`
  * 有的是 `/30`，即一个特别小的网段；运营商 2 给路由器分配的地址是 `60.190.27.190/30`，而运营商网络中的网关是 `60.190.27.189/30`

```sh
# 路由器配置的路由规则（简单解释：src 60.190.27.190 是 dev eth3 的 IP 地址）
$ ip route list table main
60.190.27.189/30 dev eth3 proto kernel scope link src 60.190.27.190
183.134.188.1 dev eth2 proto kernel scope link src 183.134.189.34
192.168.1.0/24 dev eth1 proto kernel scope link src 192.168.1.1
127.0.0.0/8 dev lo scope link
default via 183.134.188.1 dev eth2
```

此时的路由器：

* 如果走运营商 2，就从 eth3 出去
* 如果走运营商 1，就从 eth2 出去
* 如果访问内网，就走 eth1
* 如果所有的规则都没有匹配到，默认走运营商 1，即走快速网络

假设要对租户 A　进行限速：

```sh
# 添加一个路由表
$ echo 200 speed >> /etc/iproute2/rt_tables

# 添加策略路由，让来自 192.168.1.101 的网络包查看 speed 路由表
$ ip rule add from 192.168.1.101 table speed
0:  from all lookup local
32765:  from 192.168.16.101 lookup speed
32766:  from all lookup main
32767:  from all lookup default

# 路由表中添加一条规则
$ ip route add default via 60.190.27.189 dev eth3 table speed

# 刷新到系统
$ ip route flush cache
```

## 动态路由

当网络环境比较简单且在可控范围内，可以选择使用静态路由。当网络环境复杂多变时，如果总是使用静态路由，一旦网络结构发生变化，让网络管理员手工修改路由太过繁琐，因而需要使用动态路由算法。

使用动态路由路由器，可以根据路由协议算法生成动态路由表，随网络运行状况的变化而变化。网络的复杂路径可以抽象成 `图` 数据结构，因而路由算法本质是 **在图中寻找最短路径** 的算法。

求最短路径的常用方法：`Bellman-Ford 算法` 和 `Dijkstra 算法`。

| 协议大类         | 算法         | 协议子类                      |
| ---------------- | ------------ | ----------------------------- |
| 距离矢量路由协议 | Bellman-Ford | [BGP](BGP/README.md)、RIP     |
| 链路状态路由协议 | Dijkstra     | [OSPF](OSPF/README.md)、IS-IS |

### 距离矢量路由算法

距离矢量路由（distance vector routing）是基于 Bellman-Ford 算法的。

工作原理：

* 每个路由器保存一张多行路由表，每行对应网络中的一个路由器，每一行包含两部分信息，一个是 `从哪条线到达目标路由器`，另一个是 `到目标路由器的距离`。
* 由此可以看出，每个路由器都是知道全局信息的

如何更新信息：

* 每个路由器都知道自己和邻居之间的距离，每过几秒，每个路由器都将自己已知的到达所有路由器的距离告诉邻居，每个路由器也从邻居那里得到相似信息。
* 每个路由器根据新收集的信息，计算和其他路由器的距离。比如自己的一个邻居距离目标路由器的距离是 M，而自己距离邻居是 X，则自己到目标路由器的距离是 X+M 。

存在的问题：

* 好消息传得快，坏消息传得慢
* 每次发送的时候，都要发送整个全局路由表。最早的 RIP 路由协议就是这个算法。

距离矢量路由适用于小型网络（小于 15 跳），不适用于数据中心内部（因为数据中心内部路由器数量就很多）。

### 链路状态路由算法

链路状态路由（Link State routing）基于 **Dijkstra 算法**。

工作原理：

* 路由器启动时，首先发现邻居，向邻居 say hello，邻居都答复
* 计算自己和邻居的距离，发送 echo，要求马上返回，除以二就是距离
* 将自己与邻居之间的链路状态包广播出去，发送到整个网络的每个路由器，每个路由器便可以收到它和邻居之间的关系信息
* 最终，每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用 Dijkstra 算法，找到两点间的最短路径

链路状态路由协议只广播更新或改变的网络拓扑，使更新信息更小，节省了网络带宽和 CPU 利用率。

### 动态路由协议 - 基于链路状态路由算法的 OSPF

### 动态路由协议 - 基于距离矢量路由算法的 BGP

## 参考

* [路由算法](https://blog.csdn.net/qq_20233867/article/details/78335795)
* [路由算法入门](https://blog.csdn.net/qq_33936481/article/details/54379818)