# 特权级别

## 用户态（user mode）和内核态（kernel mode）

所有的现代 CPU 都提供了几种特权级别，进程可以驻留在某一特权级别。每个特权级别都有各种限制。

IA-32 体系结构使用 4 中特权级别构成的系统，各级别可以看作是 _环_。内环能够访问更多的功能，外环则较少。

尽管英特尔处理器区分 4 中特权级别，但 Linux 只使用两种不同的状态：内核态（kernel mode）和用户态（user mode）。两种状态的关键差别在于对高于 TASK_SIZE 的内存区域的访问。简而言之，在用户态禁止访问内核空间。

x86 CPU 硬件实际上提供了四个保护环：0,1,2 和 3。通常只使用环 0（内核态）和3（用户态）。

![用户态和内核态](.images/kernel-mode-vs-user-mode.png)

从用户态切换到内核态的方式：

1. 系统调用 - CPU 大多数时间都在执行用户空间中的代码，当应用程序执行系统调用时，CPU 切换到内核态，内核将完成其请求。在此期间，内核可以访问虚拟地址空间中的用户部分。在系统调用完成之后，CPU 切换会用户态。硬件中断也会使 CPU 切换到内核态，这种情况下内核不能访问用户空间。
2. 中断 - 此时切换时自动触发的，其发生几乎是不可预测的；中断事件通常中断发生时正在运行的进程无关，比如进入系统的网络包就是通过中断通知的

## 中断上下文

除了代表用户程序执行代码之外，内核还可以由异步硬件中断激活，然后在中断上下文中运行。与在进程上下文中运行的主要区别是，在中断上下文中运行不能访问虚拟地址空间中的用户空间部分。因为中断随时可能发生，中断发生时可能是人以用户进程处于活动状态，由于该进程基本上与中断的原因无关，因此内核无权访问当前用户空间的内容。

在中断上下文中运行时，内核必须比正常情况更加谨慎，例如不能进入睡眠状态。

## 内核线程

除了普通进程，系统中还有内核线程在运行。内核线程不与任何特定的用户空间进程相关联，因此无权处理用户空间。与在中断上下文运行的内核相比，内核线程可以进入睡眠状态，也可以想普通进程一样被调度器调度。

内核线程的用途：在内存和块设备之间的数据同步，到帮助调度器在 CPU 上分配进程。

```sh
# 方括号括起来的表示内核线程（斜线名称之后是 CPU 编号）
$ ps fax
  PID TTY      STAT   TIME COMMAND
    2 ?        S      0:09 [kthreadd]
    3 ?        S      0:20  \_ [ksoftirqd/0]
    5 ?        S<     0:00  \_ [kworker/0:0H]
    8 ?        S      0:06  \_ [migration/0]
    9 ?        S      0:02  \_ [rcu_bh]
   10 ?        S    356:38  \_ [rcu_sched]
   11 ?        S<     0:00  \_ [lru-add-drain]
   12 ?        S      1:41  \_ [watchdog/0]
   13 ?        S      1:38  \_ [watchdog/1]
   14 ?        S      0:06  \_ [migration/1]
   15 ?        S      0:06  \_ [ksoftirqd/1]
   17 ?        S<     0:00  \_ [kworker/1:0H]
   19 ?        S      1:31  \_ [watchdog/2]
   20 ?        S      0:05  \_ [migration/2]
   21 ?        S      0:13  \_ [ksoftirqd/2]
   23 ?        S<     0:00  \_ [kworker/2:0H]
   24 ?        S      1:29  \_ [watchdog/3]
   25 ?        S      0:06  \_ [migration/3]
   26 ?        S      0:04  \_ [ksoftirqd/3]
   28 ?        S<     0:00  \_ [kworker/3:0H]
```

在多处理器系统上，许多线程启动时指定了 CPU，并限制只能在某个特定的 CPU 上运行。
