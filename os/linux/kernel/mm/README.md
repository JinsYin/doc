# 内存管理（Memory Management）

* 内存分配
* 内存映射
* 虚拟内存操作
* POSIX 共享内存

---

* Virtual Memory
* Paging page replacement
* Page cache

由于内存区域是通过指针寻址，因此 CPU 的字（word）长决定了所能管理的地址空间的最大长度。对于 32 位处理器（如 IA-32、PPC、m68k），最大可以管理 $$2^32B = 4GB$$ 的内存地址空间；对于 64 位处理器（如 Alpha、Sparc64、IA-64、AMD64），最大可以管理 2^64B 的内存地址空间。

内存地址空间的最大长度与实际可用的物理内存数量无关，因此被称为 _虚拟地址空间_。使用该术语的另一个理由是，从系统中每个进程的角度来看，地址空间中只有自身一个进程，而无法感知到其他进程的存在。

Linux 将虚拟地址空间划分为两个部分：内核空间和用户空间

![虚拟地址空间](.images/vas.jpg)

每个用户进程都有自身的虚拟地址范围，从 0 到 TASK_SIZE 。用户空间之上的区域（从 TASK_SIZE 到 2^32 或 2^64）保留给内核专用，用户进程无法访问。TASK_SIZE 是一个特定于计算机体系结构的常数，确定了地址空间的划分比例。例如，在 IA-32 系统（虚拟地址空间总长为 4GB）中，地址空间在 3GB 处划分，因此每个进程的虚拟地址空间是 3GB （即每个用户进程都认为自身有 3 GB 内存），而内核空间是 1GB 。对于 64 位处理器，实际使用的位数一般小于 64 位，如 42 位或 47 位，好处是管理有效地址空间所需的位数较少，可以节省 CPU 的一些工作量。

## 物理内存的分配

在内核分配内存时，必须记录页帧的已分配或空闲状态，以免两个进程使用同样的物理内存区域。内核可以只分配完整的页帧，而由用户空间中的标准库将其划分为更小的区域再分配给进程。

1. 伙伴系统

内核中很多时候要求分配连续页（帧），为了快速检测内存中的连续区域，内核采用了 _伙伴系统_ 技术。

2. slab 缓存

3. 页面交换和页面回收

页面交换通过利用磁盘空间来扩展内存，从而增大了可用的内存。在内核需要更多内存时，将经常使用的页写入磁盘。如需访问相关数据，内核会将相应的页交换会内存。交换出的页可用通过特别的页表项标识。在进程试图访问此类页帧时，CPU 则启动一个可以被内核截取的缺页异常。此时内核可以将磁盘上的数据换回到内存中。接下来用户进程可以恢复运行。由于进程无法感知到缺页异常，所以页的换入和换出对进程是完全不可见的。

页面回收用于将内存映射被修改的内容与底层的块设备同步，所以有时简称为 _数据回写_。数据刷出后，内核即可将页帧用于其他用途（类似于页面交换）

## CPU 活动范围

可以将每个处理器在任何时间点的活动概括为以下三者之一：

* 运行于用户空间，执行用户进程
* 运行于内核空间，处于进程上下文，代表某个特定的进程执行
* 运行与内核空间，处于中断上下文，与任何进程无关，处理某个特定的中断

## 参考

* [Paging](https://en.wikipedia.org/wiki/Paging)
* [Memory Management](https://www.kernel.org/doc/html/latest/admin-guide/mm/index.html)
* [Linux Memory Management Documentation](https://www.kernel.org/doc/html/latest/vm/index.html)