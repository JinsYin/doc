# 平均负载（Load Average）

平均负载是最常见、最重要的系统性能指标，可以快速查看系统整体性能，反映系统整体负载情况。

```sh
$ uptime
--------
14:37:24 up 43 days,  5:27, 18 users,  load average: 1.78, 1.76, 1.60
```

三个时间间隔的平均值能够全面地分析系统负载趋势，就想可以结合早中晚三个时间点的温度来全方位了解一天的天气一样。

## 定义

单位时间内，系统中处于 **R 状态**（Running 或 Runnable） 和 **D 状态**（Uninterruptible Sleep，亦称 Disk Sleep）的进程数。

* **R 状态** - 运行或可运行状态，描述的是正在使用 CPU 或正在等待 CPU 的进程，相当于教科书中的 _运行_ 和 _就绪_ 两种状态（`ps aux | awk '$8=="R"'`）
* **D 状态** - 不可中断状态，描述的是正处于内核态关键流程中的进程，这些进程不可被中断（无法 `kill -9`），比如等待硬件设备的 I/O 响应（`ps aux | awk '$8=="D"'`）。系统对进程和硬件设备的一种保护机制。

比如，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程就处于不可中断状态。如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。

## 查看方法

* `uptime`
* `top`/`htop`/`atop`
* `cat /proc/loadavg`

当平均负载为 2 时意味着：

* 若 CPU 核数为 2，则所有的 CPU 刚好被完全占用
* 若 CPU 核数为 4，则 CPU 有 50% 的空闲
* 若 CPU 核数为 1，则有一半的进程竞争不到 CPU

## 评估 —— 平均负载为多少合理

首先需要知道系统有几个 CPU：

```sh
# 逻辑核数（包括超线程）
$ grep 'processor' /proc/cpuinfo | wc -l
4
```

通常，**当平均负载高于 CPU 数量的 70% 时**，便认为系统已过载。

## 平均负载与 CPU 使用率

平均负载囊括了 **正在使用 CPU 的进程**、**正在等待 CPU 的进程** 和 **正在等待 I/O 的进程**。

CPU 使用率，是单位时间内 CPU 繁忙情况的统计。

两者关系：

* 对于 CPU 密集型进程，会导致 CPU 使用率和平均负载都升高
* 对于 I/O 密集型进程，等待 I/O 会导致平均负载升高，但 CPU 使用率不一定升高
* 对于大量等待 CPU 的进程调度，会导致平均负载和 CPU 使用率都升高

## 工具

| Package   | 描述                                                                                                                                                                                                                                                                |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| stress    | 用于升高平均负载和压力测试                                                                                                                                                                                                                                          |
| stress-ng | stress 的下一代                                                                                                                                                                                                                                                     |
| sysstat   | 用于监控和分析系统性能：<br> * `mpstat`：多核处理器性能分析工具，用来实时查看每个 CPU 的性能指标以所有 CPU 的平均指标 <br> * `pidstat`：进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 及上下文切换等性能指标 <br> * `iostat`：CPU 统计、设备和分区的 I/O 统计 |

```sh
# RHEL（安装较新版本的 sysstat，其 pidstat 包含 %wait 列）
$ yum install stress stress-ng
$ yum localinstall https://rpmfind.net/linux/opensuse/tumbleweed/repo/oss/x86_64/sysstat-12.0.3-1.1.x86_64.rpm

# DEBIAN
$ apt install stress stress-ng sysstat
```

其他：

* atop
* htop

## 模拟实验

```sh
# 14:37:24           // 当前时间
# up 43 days,  5:27  // 系统运行时间
# 18 users           // 正在登录的用户数
# 1.78, 1.76, 1.60   // 过去 1 分钟、5 分钟、15 分钟的平均负载
$ uptime
--------
14:37:24 up 43 days,  5:27, 18 users,  load average: 1.78, 1.76, 1.60
```

```sh
$ cat /proc/loadavg
1.78 1.76 1.60 1/3095 1461266
```

超线程运行模式：

```txt
每个单位时间内，CPU 只能处理一个线程，以这样的单位进行，如果想要在单位时间内处理超过一个的线程，是不可能的，除非是有两个核心处理单元，英特尔的超线程技术便是以单个核心处理单元，去整合两个逻辑处理单元，也就是一个实体核心，两个逻辑核心，在单位时间内处理两个线程，模拟双核心运作。
```

### CPU 密集型进程

1. 模拟一个 CPU 的使用率达到 100% 的场景

```sh
# 对一个 CPU 压测五分钟
$ stress --cpu 1 --timeout 300s
-------------------------------
stress: info: [15706] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hdd
```

2. 实时查看平均负载的变化情况

```sh
# [-d]：高亮显示变化区域
$ watch -d uptime
-----------------
... load average: 0.99, 0.81, 0.47 # 1 分钟的平均负载逐步增加到 1.00
```

3. 查看 CPU 使用率的变化情况

```sh
# [-P ALL]：监控所有 CPU
# [5]：每隔 5 秒输出一组数据
$ mpstat -P ALL 5
-----------------
Linux 3.10.0-693.el7.x86_64 (ip-192-168-1-171.ceph.ew)  2019年05月31日     _x86_64_    (4 CPU)

06时49分44秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
06时49分49秒  all   25.09    0.00    0.10    0.10    0.00    0.00    0.00    0.00    0.00   74.71
06时49分49秒    0    0.20    0.00    0.00    0.40    0.00    0.00    0.20    0.00    0.00   99.20
06时49分49秒    1  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00 # CPU 使用率为 100%，而 iowait 为 0
06时49分49秒    2    0.20    0.00    0.40    0.00    0.00    0.00    0.00    0.00    0.00   99.40
06时49分49秒    3    0.20    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00   99.60
```

说明平均负载的升高是由于 CPU 使用率升高导致的。

4. 查看哪个进程导致了 CPU 使用率较高

```sh
# [-u]：报告 CPU 使用率/利用率
# [5]：每隔 5 秒输出一组数据
$ pidstat -u 5
----------------
Linux 3.10.0-693.el7.x86_64 (ip-192-168-1-171.ceph.ew)  2019年05月31日     _x86_64_    (4 CPU)

07时10分44秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command
07时10分49秒     0        10    0.20    0.00    0.00    0.20     0  watchdog/0
07时10分49秒     0     15708    0.20    0.20    0.00    0.40     0  watch
07时10分49秒     0     16974  100.00    0.00    0.00  100.00     1  stress # -_-
07时10分49秒     0     17263    0.00    0.20    0.00    0.20     0  pidstat
```

## I/O 密集型进程

1. 模拟 I/O 压力

```sh
# [--hdd]：表示读写临时文件
$ stress-ng --io 1 --hdd 1 --timeout 900s
-----------------------------------------
stress-ng: info:  [27233] dispatching hogs: 1 hdd, 1 io
```

```sh
# 不停地执行 sync() 系统调用，以刷新缓存区内存到磁盘
# 对于新机，缓存区较小，会导致无法产生大的 I/O，而更多的是系统调用，所以仅观测到 `系统 CPU 使用率` 升高
# stress --io 1 --timeout 300s
```

1. 实时查看平均负载的变化情况

```sh
$ watch -d uptime
-----------------
... load average: 3.16, 3.04, 3.11
```

3. 查看 CPU 使用率的变化情况

```sh
$ mpstat -P ALL 5
-----------------
10时15分33秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
10时15分38秒  all    0.26    0.00   18.48   34.38    0.00    0.00    0.62    0.00    0.00   46.27
10时15分38秒    0    0.20    0.00   46.67   40.20    0.00    0.00    0.20    0.00    0.00   12.73
10时15分38秒    1    0.22    0.00   16.20   44.92    0.00    0.00    1.73    0.00    0.00   36.93
10时15分38秒    2    0.00    0.00    8.38   33.74    0.00    0.00    0.20    0.00    0.00   57.67
10时15分38秒    3    0.00    0.00    2.83   19.43    0.00    0.00    0.20    0.00    0.00   77.53
```

1. 查看哪个进程导致了 iowat 较高

```sh
# [-u]：CPU 使用率
# [-d]：报告 I/O 统计
# [5]：每隔 5 秒输出一组数据
$ pidstat -u -d 5
-----------------
10时15分54秒   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
10时15分59秒     0        23    0.00    0.20    0.00    0.20    0.20     3  ksoftirqd/3
10时15分59秒     0       306    0.00    0.20    0.00    0.00    0.20     3  scsi_eh_1
10时15分59秒     0     15325    0.00    6.60    0.00    0.00    6.60     1  kworker/1:0
10时15分59秒     0     15708    0.00    0.20    0.00    0.00    0.20     0  watch
10时15分59秒     0     28078    0.20   43.80    0.00    0.00   44.00     3  stress-ng-hdd
10时15分59秒     0     28079    0.00    7.40    0.00    0.20    7.40     2  stress-ng-io
10时15分59秒     0     28388    0.00   12.60    0.00    0.20   12.60     0  kworker/u30:2
10时15分59秒     0     28790    0.20    0.40    0.00    0.00    0.60     1  pidstat

10时15分54秒   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command
10时15分59秒     0     26363      0.00      0.00      0.00       4  kworker/0:2
10时15分59秒     0     28078      0.00 265744.80      0.00     204  stress-ng-hdd
10时15分59秒     0     28079      0.00      0.00      0.00     241  stress-ng-io
10时15分59秒     0     28388      0.00      0.00      0.00     402  kworker/u30:2
```

### 大量进程

当系统运行进程超出 CPU 运行能力时，会出现等待 CPU 的进程。

1. 模拟 10 个进程

```sh
# 系统只有 4 个 CPU
$ stress --cpu 10 --timeout 300s
--------------------------------
stress: info: [25809] dispatching hogs: 10 cpu, 0 io, 0 vm, 0 hdd
```

2. 实时查看平均负载的变化情况

```sh
$ watch -d uptime
-----------------
... load average: 10.08, 8.00, 4.75 # 1 分钟的平均负载逐步增加到 10.00
```

3. 查看 CPU 使用率的变化情况

```sh
# 由此可见 CPU 是满载的
$ mpstat -P ALL 5
-----------------
Linux 3.10.0-693.el7.x86_64 (ip-192-168-1-171.ceph.ew)  2019年05月31日     _x86_64_    (4 CPU)

09时33分11秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
09时33分16秒  all   99.80    0.00    0.10    0.00    0.00    0.00    0.10    0.00    0.00    0.00
09时33分16秒    0   99.80    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00
09时33分16秒    1   99.80    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00    0.00
09时33分16秒    2   99.80    0.00    0.00    0.00    0.00    0.00    0.20    0.00    0.00    0.00
09时33分16秒    3  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00
```

4. 查看进程情况

```sh
$ pidstat -u -d 5
-----------------
```
